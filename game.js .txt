// ---------- State ----------
let hero = null;
let party = [];
let enemies = [];
let battle = null;

// ---------- Class Info ----------
const classes = {
  "Spellblade": "A balanced arcane warrior who channels magic through melee strikes.",
  "Grim Herald": "A dark mage who sacrifices vitality to unleash cursed devastation.",
  "Beastheart": "A primal tamer that fights alongside summoned wild familiars.",
  "Stormbreaker": "A thunder-armored tank that controls lightning and shields allies.",
  "Dawnpriest": "A radiant healer who restores allies and burns foes with holy light."
};

// ---------- Spells (60) + Attacks (same as before) ----------
/* (Use the same SPELLS data as in your previous complete upgrade)
   For brevity here we re-use the previous SPELLS object structure.
   If you already pasted the previous full 60 list, keep it (no change needed).
   Otherwise you can paste that big SPELLS block from the earlier upgrade.
*/
// For runtime, paste the previous full SPELLS object here (omitted for brevity in this snippet).
// ---- To keep the answer concise I will re-use the previously-defined SPELLS constant
// If it's missing in your current repo, replace this comment with the full SPELLS object from the earlier file.

// ---------- Helpers ----------
function $(id){ return document.getElementById(id); }
function rollDice(notation){
  if(!notation) return 0;
  notation = String(notation).replace(/\s+/g,'');
  let plus = 0;
  if(notation.includes('+')){
    const parts = notation.split('+');
    notation = parts[0]; plus = parseInt(parts[1])||0;
  }
  if(!notation.includes('d')) return parseInt(notation||0)+plus;
  const [n,m] = notation.split('d').map(Number);
  let s=0;
  for(let i=0;i<n;i++) s += 1 + Math.floor(Math.random()*m);
  return s + plus;
}

// ---------- Persistence ----------
function saveAll(){ localStorage.setItem("arcane_hero_v2", JSON.stringify({hero,party})); }
function loadAll(){
  const s = localStorage.getItem("arcane_hero_v2");
  if(!s) return false;
  const parsed = JSON.parse(s);
  hero = parsed.hero; party = parsed.party || [hero];
  return true;
}
function clearAllConfirm(){
  if(confirm("Delete saved hero and data?")){ clearAll(); }
}
function clearAll(){ localStorage.removeItem("arcane_hero_v2"); location.reload(); }

// ---------- Create hero ----------
function rollStat(){ let arr=Array.from({length:5},()=>Math.ceil(Math.random()*6)); arr.sort((a,b)=>a-b); arr.splice(0,2); return arr.reduce((a,b)=>a+b,0); }

function createHero(){
  hero = {
    name: $('heroName').value || 'Hero',
    race: $('raceSelect').value,
    class: $('classSelect').value,
    level:1, xp:0,
    stats: {STR:rollStat(), DEX:rollStat(), CON:rollStat(), INT:rollStat(), WIS:rollStat(), CHA:rollStat()},
    maxHp: 50 + rollStat(), hp: 50,
    maxMp: 30, mp: 30,
    slots: {"1":2,"2":1,"3":0,"4":0,"5":0},
    knownSpells: ['ember_dart'],
    quickSpells: [null,null,null], // quick hotbar slots (indices)
    weapon: 'Longsword'
  };
  party = [Object.assign({}, hero)];
  saveAll(); refreshAll(); goTo('screen-hud');
}

// ---------- UI refresh ----------
function refreshAll(){
  if(!hero) return;
  $('hud-name').innerText = hero.name;
  $('hud-race').innerText = hero.race;
  $('hud-class').innerText = hero.class;
  $('hud-level').innerText = `Level ${hero.level} (XP ${hero.xp}/${hero.level*100})`;

  $('hp-fill').style.width = Math.max(0, Math.min(100, Math.floor(hero.hp/hero.maxHp*100))) + '%';
  $('mp-fill').style.width = Math.max(0, Math.min(100, Math.floor(hero.mp/hero.maxMp*100))) + '%';

  // slots display
  let sx = '';
  Object.keys(hero.slots).sort((a,b)=>+a-+b).forEach(l=>{ sx += `L${l}:${hero.slots[l]} &nbsp;`; });
  $('slots-box').innerHTML = sx;

  // stats
  $('hud-stats').innerHTML = '';
  Object.keys(hero.stats).forEach(k=> $('hud-stats').innerHTML += `${k}: ${hero.stats[k]}<br/>`);

  // party box
  $('party-box').innerHTML = '';
  party.forEach((p,idx)=>{ const d = document.createElement('div'); d.innerHTML = `${idx===0?'<b>(You)</b> ':''}${p.name} Lv${p.level} HP:${p.hp}/${p.maxHp}`; $('party-box').appendChild(d); });

  renderKnownSpells(); renderAvailableSpells(); renderAttacks(); renderQuickBar(); renderEnemiesList();
}

// ---------- Quick bar rendering & assignment ----------
function renderQuickBar(){
  for(let i=0;i<3;i++){
    const btn = $(`quick-${i+1}`);
    const key = hero.quickSpells && hero.quickSpells[i];
    if(key && SPELLS && SPELLS[key]) btn.innerText = SPELLS[key].name;
    else btn.innerText = `Quick ${i+1}`;
  }
}

// assign a spell to a quick slot
function assignQuickSpell(spellKey, slotIndex){
  hero.quickSpells = hero.quickSpells || [null,null,null];
  hero.quickSpells[slotIndex] = spellKey;
  saveAll(); refreshAll();
  alert(`${SPELLS[spellKey].name} assigned to Quick ${slotIndex+1}`);
}

// quick cast wrapper
function quickCast(slotIndex){
  const key = hero.quickSpells && hero.quickSpells[slotIndex];
  if(!key){ alert('No spell assigned to this slot'); return; }
  castSpellWithTargeting(key);
}

// ---------- Spells UI ----------
function renderKnownSpells(){
  const box = $('known-spells'); box.innerHTML = '';
  (hero.knownSpells||[]).forEach(k=>{
    const s = SPELLS[k]; if(!s) return;
    const div = document.createElement('div');
    // add assign buttons
    div.innerHTML = `<b>${s.name}</b> (Lv${s.level}) - ${s.description} <button onclick="castSpellWithTargeting('${k}')">Cast</button> 
      <button onclick="showAssignMenu('${k}')">Assign</button>`;
    box.appendChild(div);
  });
}
function showAssignMenu(key){
  const body = $('modal-body'); const title = $('modal-title');
  title.innerText = `Assign ${SPELLS[key].name} to quick slot`;
  body.innerHTML = '';
  for(let i=0;i<3;i++){
    const b = document.createElement('button');
    b.innerText = `Assign to Quick ${i+1}`;
    b.onclick = ()=>{ assignQuickSpell(key,i); $('modal').classList.add('hidden'); };
    body.appendChild(b);
  }
  $('modal').classList.remove('hidden');
  $('modal-ok').onclick = ()=>{$('modal').classList.add('hidden');};
}

function renderAvailableSpells(){
  const box = $('available-spells'); box.innerHTML = '';
  for(const key in SPELLS){
    const sp = SPELLS[key];
    if(sp.class.includes(hero.class) && (!hero.knownSpells || !hero.knownSpells.includes(key))){
      const div=document.createElement('div');
      div.innerHTML = `${sp.name} (Lv ${sp.level}) — ${sp.description} <button onclick="learnSpell('${key}')">Learn</button>`;
      box.appendChild(div);
    }
  }
}

function learnSpell(key){
  hero.knownSpells = hero.knownSpells || [];
  if(hero.knownSpells.includes(key)) return alert('Already known');
  hero.knownSpells.push(key); saveAll(); refreshAll();
  appendLog(`${hero.name} learned ${SPELLS[key].name}`);
}

// ---------- Resource consumption ----------
function chooseAndConsumeResource(key){
  const meta = SPELLS[key]; if(!meta) return {type:null};
  if(meta.slot_level && meta.slot_level>0){
    const lvl = String(meta.slot_level);
    if(hero.slots && hero.slots[lvl] && hero.slots[lvl]>0){ hero.slots[lvl]--; return {type:'slot',level:meta.slot_level}; }
  }
  if(meta.mana && hero.mp >= meta.mana){ hero.mp -= meta.mana; return {type:'mana',amount:meta.mana}; }
  return {type:null};
}

// ---------- Targeting behavior (C): auto if 1 enemy, choose if multiple ----------
function chooseTargetForSpell(meta, onChosen){
  if(!enemies || enemies.length === 0){
    // healing spells: if party length==1 auto-heal self, else choose
    if(meta.target === 'heal'){
      if(party.length <= 1) return onChosen({type:'ally', index:0}); // self
      // choose ally (modal)
      const body = $('modal-body'); const title = $('modal-title'); title.innerText = 'Choose ally to heal';
      body.innerHTML = '';
      party.forEach((p,idx)=>{ const b=document.createElement('button'); b.innerText = `${p.name} Lv${p.level}`; b.onclick=()=>{ $('modal').classList.add('hidden'); onChosen({type:'ally', index:idx}); }; body.appendChild(b); });
      $('modal').classList.remove('hidden'); $('modal-ok').onclick=()=>{$('modal').classList.add('hidden');};
      return;
    }
    return onChosen(null);
  }

  if(enemies.length === 1){
    return onChosen({type:'enemy', index:0});
  } else {
    // multiple enemies: require player selection
    const body = $('modal-body'); const title = $('modal-title'); title.innerText = 'Choose target';
    body.innerHTML = '';
    enemies.forEach((e,idx)=>{ const b=document.createElement('button'); b.innerText = `${e.name} (${Math.max(0,e.hp)} HP)`; b.onclick=()=>{ $('modal').classList.add('hidden'); onChosen({type:'enemy', index:idx}); }; body.appendChild(b); });
    $('modal').classList.remove('hidden'); $('modal-ok').onclick=()=>{$('modal').classList.add('hidden');};
    return;
  }
}

// ---------- Cast with targeting flow ----------
function castSpellWithTargeting(key){
  const meta = SPELLS[key];
  if(!meta) return alert('Spell missing.');
  // check resource availability first but don't consume until confirmed
  const canCast = (function(){
    // slot or mana available?
    if(meta.slot_level && meta.slot_level>0){
      const lvl=String(meta.slot_level);
      if(hero.slots && hero.slots[lvl] && hero.slots[lvl]>0) return true;
    }
    if(meta.mana && hero.mp >= meta.mana) return true;
    if((meta.slot_level===0 || !meta.slot_level) && (!meta.mana || meta.mana===0)) return true;
    return false;
  })();
  if(!canCast) return alert('Not enough spell slots or mana.');

  // choose target per rules
  chooseTargetForSpell(meta, (target)=>{
    if(target === null && meta.target !== 'heal'){ appendLog('No valid target.'); return; }
    // now consume resource
    const res = chooseAndConsumeResource(key);
    if(res.type === null){ alert('No slots or mana'); return; }

    // apply effect
    if(meta.target === 'single' || meta.target === 'aoe'){
      if(meta.target === 'single'){
        if(target.type !== 'enemy') { appendLog('Invalid target for this spell.'); return; }
        const e = enemies[target.index];
        const dmg = rollDice(meta.damage || '0');
        e.hp -= dmg; showPopupOnEnemy(target.index, `-${dmg}`, 'damage');
        appendLog(`${hero.name} casts ${meta.name} on ${e.name} for ${dmg}.`);
      } else { // aoe
        const dmg = rollDice(meta.damage || '0');
        enemies.forEach((e,idx)=>{ e.hp -= dmg; showPopupOnEnemy(idx, `-${dmg}`, 'damage'); });
        appendLog(`${hero.name} casts ${meta.name} (AoE) for ${dmg} each.`);
      }
    } else if(meta.target === 'heal'){
      if(target.type === 'ally'){
        const p = party[target.index];
        // heal party member (if target is hero index 0)
        const heal = rollDice(meta.heal || '0');
        if(target.index === 0){ hero.hp = Math.min(hero.maxHp, hero.hp + heal); showPopupOnHero(`+${heal}`, 'heal'); appendLog(`${hero.name} heals self for ${heal}.`); }
        else { /* NPC heal path (future) */ appendLog(`${hero.name} heals ${p.name} for ${heal}.`); }
      }
    }

    // cleanup, XP, enemy phase
    cleanupDeadEnemies();
    saveAll(); refreshAll(); updateEnemyCards();
    enemyPhase(); // enemies act after cast
  });
}

// ---------- cleanup & enemy updates ----------
function cleanupDeadEnemies(){
  const before = enemies.length;
  enemies = enemies.filter(e=>e.hp>0);
  if(enemies.length < before){
    const defeated = before - enemies.length;
    appendLog(`Enemy defeated! (+${50*defeated} XP)`);
    hero.xp = (hero.xp||0) + (50 * defeated);
    checkLevelUp();
  }
}

function updateEnemyCards(){ renderEnemiesList(); }

// ---------- Combat: startEncounter, renderEnemiesList ----------
function startEncounter(count=1){
  if(!hero) return alert('Create hero first.');
  enemies = [];
  for(let i=0;i<count;i++){
    const base = 80 + Math.floor(Math.random()*40);
    enemies.push({ id:i, name: (count>1? `Crawler #${i+1}` : 'Umbra Warden'), hp:base, maxHp:base });
  }
  battle = { turn:'player', targetIndex:0 };
  appendLog(`Encounter: ${enemies.length} enemy(ies).`);
  saveAll(); refreshAll(); goTo('screen-combat');
}
function renderEnemiesList(){
  const container = $('enemies-list'); if(!container) return;
  container.innerHTML = '';
  enemies.forEach((e,idx)=>{
    const card = document.createElement('div'); card.className='enemy-card'; card.id=`enemy-${idx}`;
    const hpPct = Math.max(0, Math.floor((e.hp/e.maxHp)*100));
    card.innerHTML = `<div><b>${e.name}</b></div><div style="height:6px;"></div>
      <div class="bar"><div style="width:${hpPct}%;height:10px;background:#c72c41;"></div></div>
      <div style="height:6px;"></div>
      <button onclick="selectTarget(${idx})">Target</button>`;
    container.appendChild(card);
  });
}

// ---------- Player actions ----------
function playerAction(type){
  if(type === 'attack'){
    if(enemies.length === 0) return appendLog('No enemies.');
    const idx = battle.targetIndex || 0;
    const enemy = enemies[idx];
    if(!enemy) return appendLog('Invalid target.');
    // simple attack formula
    const base = 1 + Math.floor(Math.random()*8) + Math.floor((hero.stats.STR-10)/2);
    enemy.hp -= base; showPopupOnEnemy(idx, `-${base}`, 'damage'); appendLog(`${hero.name} attacks ${enemy.name} for ${base}.`);
    cleanupDeadEnemies(); saveAll(); refreshAll(); updateEnemyCards();
    enemyPhase();
  } else if(type === 'defend'){
    hero._defend = true; appendLog(`${hero.name} braces for incoming attacks.`); enemyPhase();
  }
}

// select target (set battle.targetIndex)
function selectTarget(idx){ battle = battle || {}; battle.targetIndex = idx; appendLog(`Target set to ${enemies[idx].name}`); }

// ---------- Enemy phase ----------
function enemyPhase(){
  if(enemies.length === 0) return;
  enemies.forEach(e=>{
    if(hero.hp <= 0) return;
    let dmg = 6 + Math.floor(Math.random()*6);
    if(hero._defend){ dmg = Math.max(1, Math.floor(dmg/2)); hero._defend = false; }
    hero.hp -= dmg; showPopupOnHero(`-${dmg}`, 'damage'); appendLog(`${e.name} hits ${hero.name} for ${dmg}.`);
  });
  saveAll(); refreshAll(); cleanupDeadEnemies();
  if(hero.hp <= 0){ appendLog('You were defeated.'); goTo('screen-hud'); }
}

// ---------- Level & XP ----------
function checkLevelUp(){
  while(hero.xp >= hero.level * 100){
    hero.xp -= hero.level * 100; hero.level++;
    appendLog(`${hero.name} reached Level ${hero.level}! Choose +1 to a stat.`);
    autoTeachForLevel(hero.class, hero.level); promptStatChoice();
  }
  saveAll(); refreshAll();
}
function promptStatChoice(){
  const body = $('modal-body'); const title = $('modal-title'); title.innerText = `Level Up - choose +1 stat (Level ${hero.level})`; body.innerHTML = '';
  Object.keys(hero.stats).forEach(s=>{ const b=document.createElement('button'); b.innerText = `${s}: ${hero.stats[s]}`; b.onclick = ()=>{ hero.stats[s]++; saveAll(); $('modal').classList.add('hidden'); refreshAll(); }; body.appendChild(b); });
  $('modal').classList.remove('hidden'); $('modal-ok').onclick = ()=>{$('modal').classList.add('hidden');};
}

// ---------- Auto-teach mapping (reuse earlier mapping if present) ----------
function autoTeachForLevel(cls,lvl){
  // AUTO_TEACH object should be present from your previous full file — keep it there.
  if(window.AUTO_TEACH && AUTO_TEACH[cls] && AUTO_TEACH[cls][lvl]){
    AUTO_TEACH[cls][lvl].forEach(k=>{ if(!(hero.knownSpells||[]).includes(k)){ hero.knownSpells.push(k); appendLog(`${hero.name} auto-learned ${SPELLS[k].name}`); }});
  }
}

// ---------- Rest mechanics ----------
function shortRest(){
  if(!hero) return;
  const mpGain = Math.max(1, Math.floor(hero.maxMp * 0.25));
  hero.mp = Math.min(hero.maxMp, hero.mp + mpGain);
  if(hero.slots && hero.slots['1'] !== undefined){
    hero.slots['1'] = Math.min(2, hero.slots['1'] + 1); // restore 1 of level-1 slot
  }
  appendLog(`${hero.name} took a Short Rest (+${mpGain} MP).`);
  saveAll(); refreshAll();
}
function longRest(){
  if(!hero) return;
  hero.hp = hero.maxHp; hero.mp = hero.maxMp;
  Object.keys(hero.slots).forEach(k=> hero.slots[k] = getDefaultSlotCount(k));
  appendLog(`${hero.name} took a Long Rest (full restore).`);
  saveAll(); refreshAll();
}
function getDefaultSlotCount(level){
  level = Number(level);
  if(level === 1) return 2;
  if(level === 2) return 1;
  return 0;
}

// ---------- Popups ----------
function showPopupOnEnemy(idx, text, type){
  const card = $(`enemy-${idx}`); if(!card) return;
  const popup = document.createElement('div'); popup.className = 'damage-popup'; if(type==='heal') popup.classList.add('heal'); popup.innerText = text; card.appendChild(popup);
  setTimeout(()=>popup.remove(),800);
}
function showPopupOnHero(text, type){
  const container = $('hud-name'); if(!container) return;
  const popup = document.createElement('div'); popup.className='damage-popup'; if(type==='heal') popup.classList.add('heal'); popup.style.position='relative'; popup.innerText=text; container.appendChild(popup);
  setTimeout(()=>popup.remove(),800);
}

// ---------- Cast modal (All Spells) ----------
function openCastModal(){
  if(!(hero && hero.knownSpells && hero.knownSpells.length)) return alert('No spells known.');
  const body = $('cast-body'); body.innerHTML = '';
  hero.knownSpells.forEach(k=>{
    const s = SPELLS[k]; if(!s) return;
    const div = document.createElement('div');
    div.innerHTML = `<b>${s.name}</b> (Lv${s.level}) - ${s.description}
      <button onclick="castSpellWithTargeting('${k}')">Cast</button>
      <button onclick="showAssignMenu('${k}')">Assign</button>`;
    body.appendChild(div);
  });
  $('castModal').classList.remove('hidden');
}
function closeCastModal(){ $('castModal').classList.add('hidden'); }

// ---------- Attacks UI (simple) ----------
function renderAttacks(){
  if(!hero) return;
  $('class-attacks').innerHTML = '';
  $('weapon-attacks').innerHTML = '';
  (window.CLASS_ATTACKS && (CLASS_ATTACKS[hero.class]||[])).forEach(a=> $('class-attacks').innerHTML += `${a.name} (${a.dice})<br/>`);
  (window.WEAPON_ATTACKS && (WEAPON_ATTACKS[hero.weapon]||[])).forEach(a=> $('weapon-attacks').innerHTML += `${a.name} (${a.dice})<br/>`);
}

// ---------- Log & navigation ----------
function appendLog(t){ const b=$('battle-log'); if(!b) return; b.innerHTML += t + '<br/>'; b.scrollTop = b.scrollHeight; }
function goTo(id){ document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden')); document.getElementById(id).classList.remove('hidden'); }

// ---------- Init ----------
window.onload = function(){
  // Ensure SPELLS, AUTO_TEACH, CLASS_ATTACKS, WEAPON_ATTACKS are present (from prior full files).
  if(loadAll()){ refreshAll(); return; }
  $('modal-ok').onclick = ()=>{$('modal').classList.add('hidden'); refreshAll();};
};
